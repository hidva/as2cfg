package parser

import "fmt"

type Expression interface {
	/* used to generate the text representation of this expression */
	String() string
}

/* Always is an expression means always true, a CFGEdge generated by JMP will use Always as its expression. */
type Always struct {
}

func (this *Always) String() string {
	/* maybe look better than "TRUE"/"ALWAYS"... */
	return ""
}

const /* compare operator */ (
	COMP_OP_LESS         = "<"
	COMP_OP_LESSEQUAL    = "<="
	COMP_OP_EQUAL        = "=="
	COMP_OP_NOTEQUAL     = "!="
	COMP_OP_GREATER      = ">"
	COMP_OP_GREATEREQUAL = ">="
)

func Negate(op string) string {
	switch op {
	case COMP_OP_LESS:
		return COMP_OP_GREATEREQUAL
	case COMP_OP_LESSEQUAL:
		return COMP_OP_GREATER
	case COMP_OP_EQUAL:
		return COMP_OP_NOTEQUAL
	case COMP_OP_NOTEQUAL:
		return COMP_OP_EQUAL
	case COMP_OP_GREATER:
		return COMP_OP_LESSEQUAL
	case COMP_OP_GREATEREQUAL:
		return COMP_OP_LESS
	}
	panic("unreachable")
	return ""
}

/* https://golang.org/ref/spec#Comparison_operators */
type CompExpression struct {
	Op          string /* "<", "<=", etc. */
	Left, Right Expression
}

func (this *CompExpression) String() string {
	return fmt.Sprintf("%s %s %s", this.Left.String(), this.Op, this.Right.String())
}

func (this *CompExpression) Not() {
	this.Op = Negate(this.Op)
}

/* https://golang.org/ref/spec#Logical_operators */
const /* logical operator */ (
	LOGICAL_OP_AND = "&&"
	LOGICAL_OP_OR  = "||"
)

type LogicalExpr struct {
	Op          string
	Left, Right Expression
}

func (this *LogicalExpr) String() string {
	return fmt.Sprintf("%s %s %s", this.Left.String(), this.Op, this.Right.String())
}

type NotExpression struct {
	Operand Expression
}

func (this *NotExpression) String() string {
	return "!(" + this.Operand.String() + ")"
}
